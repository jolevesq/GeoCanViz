// https://github.com/odoe/esri-clusterfeaturelayer
// https://developers.arcgis.com/javascript/jssamples/layers_point_clustering.html
/*
 * This dependency has been modified a lot to suit GCViz purpose
 */
define([
  "dojo/_base/declare",
  "dojo/_base/array",
  "dojo/_base/Color",
  "dojo/_base/connect",
  "esri/SpatialReference",
  "esri/geometry/Point",
  "esri/graphic",
  "esri/symbols/SimpleMarkerSymbol",
  'esri/symbols/SimpleLineSymbol',
  "esri/symbols/TextSymbol",
  'esri/renderers/ClassBreaksRenderer',
  "esri/dijit/PopupTemplate",
  "esri/layers/GraphicsLayer"
], function (
  declare, arrayUtils, Color, connect,
  SpatialReference, Point, Graphic, SimpleMarkerSymbol, SimpleLineSymbol, TextSymbol, ClassBreaksRenderer,
  PopupTemplate, GraphicsLayer
) {
  return declare([GraphicsLayer], {
    constructor: function(options) {
      // options:
      //   data:  Object[]
      //     Array of objects. Required. Object are required to have properties named x, y and attributes. The x and y coordinates have to be numbers that represent a points coordinates.
      //   distance:  Number?
      //     Optional. The max number of pixels between points to group points in the same cluster. Default value is 50.
      //   labelColor:  String?
      //     Optional. Hex string or array of rgba values used as the color for cluster labels. Default value is #fff (white).
      //   labelOffset:  String?
      //     Optional. Number of pixels to shift a cluster label vertically. Defaults to -5 to align labels with circle symbols. Does not work in IE.
      //   resolution:  Number
      //     Required. Width of a pixel in map coordinates. Example of how to calculate: 
      //     map.extent.getWidth() / map.width
      //   showSingles:  Boolean?
      //     Optional. Whether or graphics should be displayed when a cluster graphic is clicked. Default is true.
      //   singleSymbol:  MarkerSymbol?
      //     Marker Symbol (picture or simple). Optional. Symbol to use for graphics that represent single points. Default is a small gray SimpleMarkerSymbol.
      //   spatialReference:  SpatialReference?
      //     Optional. Spatial reference for all graphics in the layer. This has to match the spatial reference of the map. Default is 102100. Omit this if the map uses basemaps in web mercator.
      
      this._clusterTolerance = options.distance || 50;
      this._clusterData = options.data || [];
      this._clusterLabel = options.label || false;
      this._layerId = options.id;
      // labelOffset can be zero so handle it differently
      this._clusterLabelOffset = (options.hasOwnProperty("labelOffset")) ? options.labelOffset : -5;
      // graphics that represent a single point
      this._showSingles = options.hasOwnProperty("showSingles") ? options.showSingles : true;
      this._singleSym = options.singleSymbol || new SimpleMarkerSymbol("circle", 6, null, new Color("#888"));

      this._sr = options.spatialReference || new SpatialReference({ "wkid": 102100 });
	  this._defaultRenderer = options.renderer || null;
	  this._maxSizeProp = options.maxSizeProp || 50;
	  this._maxDataProp = options.maxDataProp || 1000;
	 
	  // predefine values
	  this._clusterLabelColor = "#000";
	  this._clusterField = '';
      this._singles = []; // populated when a graphic is clicked
      this._featExtent = []; // data in map extent
      this._clusters = []; // clusters array
    },

	// override esri/layers/GraphicsLayer methods 
	_setMap: function(map, surface) {
		// calculate and set the initial resolution
		this._clusterResolution = map.extent.getWidth() / map.width; // probably a bad default...
		
		// set renderer
		this._setRenderer(this._defaultRenderer, this._clusterData.length);
		
		// get only feature in zoom extent (j. levesque)
		this._getFeatExtent(map);
		this._clusterGraphics();

      // connect to onZoomEnd so data is re-clustered when zoom level changes
      // replace by onExtentChange and get only feature in zoom extent
      this._zoomEnd = connect.connect(map, "onExtentChange", this, function() {
        // update resolution
        this._clusterResolution = this._map.extent.getWidth() / this._map.width;
        this._clear();
        this._clearSingles(this._singles);
        
        // get only feature in zoom extent for visible layer
        if (map.getLayer(this._layerId).visible) {
			this._getFeatExtent(map);
        	this._clusterGraphics();
        }
      });

      // GraphicsLayer will add its own listener here
      var div = this.inherited(arguments);
      return div;
    },
	
	_getFeatExtent: function(map) {
		this._featExtent = [];
        var feat, geom,
        	layer = map.getLayer(this._layerId),
        	features = layer._clusterData;
        	len = layer._clusterData.length;
        while (len--) {
        	feat = features[len];
        	geom = new Point(feat.x, feat.y, this._sr);
        	
			if (map.extent.contains(geom)) {
            	this._featExtent.push(feat);
			}
        }
	},
	
	_setRenderer: function(renderer, nbItems) {
		
		if (renderer === null) {
			var renderBreak = parseInt(nbItems / 100, 10),
				sms = SimpleMarkerSymbol,
				sls = SimpleLineSymbol,
				defaultSym = new sms('circle').setSize(5),
				renderer = new ClassBreaksRenderer(defaultSym, 'clusterCount'),
				small = new sms('circle', 20,
						new sls(sls.STYLE_SOLID, new Color([255,125,0,0.25]), 10),
						new Color([255,125,0,0.5])),
				medium = new sms('circle', 30,
						new sls(sls.STYLE_SOLID, new Color([255,0,250,0.25]), 10),
						new Color([255,0,250,0.5])),
				large = new sms('circle', 50,
						new sls(sls.STYLE_SOLID, new Color([255,0,0,0.25]), 10),
						new Color([255,0,0,0.5]));

			renderer.addBreak(1, renderBreak * 5, small);
			renderer.addBreak(renderBreak * 5, renderBreak * 15, medium);
			renderer.addBreak(renderBreak * 15, Infinity, large);
		} else {
			var proportionalSymbolInfo = {
					field:'clusterCount',
					valueUnit: 'unknown',
					minSize: renderer.infos[0].symbol.height,
          			maxSize: this._maxSizeProp,
          			minDataValue: 1,
					maxDataValue: this._maxDataProp
				};
			renderer.setProportionalSymbolInfo(proportionalSymbolInfo);
			
			// set the field for clustering
			this._clusterField = renderer.attributeField;
		}

		this.setRenderer(renderer);
	},
	
    _unsetMap: function() {
      this.inherited(arguments);
      connect.disconnect(this._zoomEnd);
    },

    _clear: function() {
      // Summary:  Remove all clusters and data points.
      this.clear();
      this.inherited(arguments);
      this._clusters = [];
    },

    _clearSingles: function(singles) {
		// Summary:  Remove graphics that represent individual data points.
		var len = singles.length;
      
		while (len--) {
			this.remove(singles[len]);
		}
		this._singles = [];
    },

    onClick: function(e) {
    	var len, cluster, cursor,
    		singles = [],
    		mapid = e.target.viewportElement.id.split('_')[0];
    	
    	// check if cursor is default. If not, do not apply click
    	cursor = $('#' + mapid + '_holder_container').css('cursor');
    	
    	if (cursor === 'default') {
    		// remove any previously showing single features
			this._clearSingles(this._singles);

			// find single graphics that make up the cluster that was clicked
			// would be nice to use filter but performance tanks with large arrays in IE
			len = this._clusterData.length;
	      
			while (len--) {
				cluster = this._clusterData[len];
				if (e.graphic.attributes.clusterId === cluster.attributes.clusterId) {
					singles.push(cluster);
				}
			}
	
			// stop the click from bubbling to the map
			e.stopPropagation();
			this._addSingles(singles);
    	}
    },

    // internal methods 
    _clusterGraphics: function() {
      // first time through, loop through the points
      for ( var j = 0, jl = this._featExtent.length; j < jl; j++ ) {
        // see if the current feature should be added to a cluster
        var point = this._featExtent[j];
        var clustered = false;
        var numClusters = this._clusters.length;
        for ( var i = 0; i < this._clusters.length; i++ ) {
          var c = this._clusters[i];
          if ( this._clusterTest(point, c) ) {
            this._clusterAddPoint(point, c);
            clustered = true;
            break;
          }
        }

        if ( ! clustered ) {
          this._clusterCreate(point);
        }
      }
      this._showAllClusters();
    },

    _clusterTest: function(p, cluster) {
		var field = this._clusterField,
			distance = (
				Math.sqrt(
					Math.pow((cluster.x - p.x), 2) + Math.pow((cluster.y - p.y), 2)
				) / this._clusterResolution
			);
		
		if (field === '') {
			return (distance <= this._clusterTolerance);
		} else {
			return (distance <= this._clusterTolerance && p.attributes[field] >= cluster.attributes.clsMin && p.attributes[field] <= cluster.attributes.clsMax);
		}
    },

    // points passed to clusterAddPoint should be included 
    // in an existing cluster
    // also give the point an attribute called clusterId 
    // that corresponds to its cluster
    _clusterAddPoint: function(p, cluster) {
		// average in the new point to the cluster geometry
		var count = cluster.attributes.clusterCount,
			attr = cluster.attributes,
			x = (p.x + (cluster.x * count)) / (count + 1),
			y = (p.y + (cluster.y * count)) / (count + 1);

		cluster.x = x;
		cluster.y = y;

		// build an extent that includes all points in a cluster
		// extents are for debug/testing only...not used by the layer
		if ( p.x < attr.extent[0] ) {
			attr.extent[0] = p.x;
		} else if ( p.x > attr.extent[2] ) {
			attr.extent[2] = p.x;
		}
		if ( p.y < attr.extent[1] ) {
			attr.extent[1] = p.y;
		} else if ( p.y > attr.extent[3] ) {
			attr.extent[3] = p.y;
		}

		// increment the count
		attr.clusterCount++;
     
		// attributes might not exist
		if ( ! p.hasOwnProperty("attributes") ) {
			p.attributes = {};
		}
		// give the graphic a cluster id
		p.attributes.clusterId = attr.clusterId;
    },

    // point passed to clusterCreate isn't within the 
    // clustering distance specified for the layer so
    // create a new cluster for it
    _clusterCreate: function(p) {
		var len, value, breaks, clsAttr,
			cluster,
			clusters = this._clusters,
			clusterId = this._clusters.length + 1,
			attr = p.attributes;

		// p.attributes might be undefined
		if ( !attr ) {
			attr = {};
		}
		attr.clusterId = clusterId;
		attr.clusterCount = 1;
		attr.extent = [ p.x, p.y, p.x, p.y ];
      
		// create the cluster
		cluster = { 
			"x": p.x,
			"y": p.y
		};
		
		// add the clustering attribute
		if (this._clusterField !== '') {
			breaks = this._defaultRenderer.infos;
			len = breaks.length;
			clsAttr = attr[this._clusterField];
			
			while (len--) {
				value = breaks[len];
				if (clsAttr >= value.minValue && clsAttr < value.maxValue) {
					attr.clsMin = value.minValue;
					attr.clsMax = value.maxValue;
				}
			}
		}
		
		cluster.attributes = attr;
		clusters.push(cluster);
    },

    _showAllClusters: function() {
		var len = this._clusters.length;
		
		while (len--) {
			this._showCluster(this._clusters[len]);
		}
    },

    _showCluster: function(c) {
		var label = null,
			point = new Point(c.x, c.y, this._sr),
			attr = c.attributes;
		
		// add the point with the symbol
		this.add(
			new Graphic(
				point, 
				null, 
				attr
			)
		);
		
		// code below is used to to label clusters if not a single point and
		// if label is set to true
		if (attr.clusterCount !== 1 && this._clusterLabel) {
			label = new TextSymbol(attr.clusterCount)
				.setColor(new Color(this._clusterLabelColor))
				.setOffset(0, this._clusterLabelOffset);
			
			// show number of points in the cluster
			this.add(
			new Graphic(
				point,
				label,
				attr
				)
			);
		}
    },

    _addSingles: function(singles) {
		// add single graphics to the map
		var p, g,
			len = singles.length;
      
		while (len--) {
			p = singles[len];
			g = new Graphic(
					new Point(p.x, p.y, this._sr),
					this._singleSym,
					p.attributes,
					this._singleTemplate
				);
				
			this._singles.push(g);
			if ( this._showSingles ) {
				this.add(g);
			}
		}
	},

    _updateClusterGeometry: function(c) {
      // find the cluster graphic
      var cg = arrayUtils.filter(this.graphics, function(g) {
        return ! g.symbol &&
               g.attributes.clusterId == c.attributes.clusterId;
      });
      if ( cg.length == 1 ) {
        cg[0].geometry.update(c.x, c.y);
      } else {
        console.log("didn't find exactly one cluster geometry to update: ", cg);
      }
    },

    _updateLabel: function(c) {
      // find the existing label
      var label = arrayUtils.filter(this.graphics, function(g) {
        return g.symbol && 
               g.symbol.declaredClass == "esri.symbol.TextSymbol" &&
               g.attributes.clusterId == c.attributes.clusterId;
      });
      if ( label.length == 1 ) {
        // console.log("update label...found: ", label);
        this.remove(label[0]);
        var newLabel = new TextSymbol(c.attributes.clusterCount)
          .setColor(new Color(this._clusterLabelColor))
          .setOffset(0, this._clusterLabelOffset);
        this.add(
          new Graphic(
            new Point(c.x, c.y, this._sr),
            newLabel,
            c.attributes
          )
        );
        // console.log("updated the label");
      } else {
        console.log("didn't find exactly one label: ", label);
      }
    }

  });
});

